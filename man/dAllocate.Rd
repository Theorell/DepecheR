% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dAllocate.R
\name{dAllocate}
\alias{dAllocate}
\title{Allocation of observations to pre-established cluster centers.}
\usage{
dAllocate(inDataFrameScaled, clusterCenters, withOrigoClust, ids)
}
\arguments{
\item{inDataFrameScaled}{A dataframe with the data that will be used to create the clustering. The data in this dataframe should be scaled in a proper way. Empirically, many datasets seem to be clustered in a meaningful way if they are scaled with the dScale function. It should naturally be scaled together with the data used to genreate the cluster centers.}

\item{clusterCenters}{This is a matrix that needs to be inherited from a dClust run. It contains the information about which clusters and variables that have been sparsed away and where the cluster centers are located for the remaining clusters and variables.}

\item{ids}{A vector of the same length as rows in the inDataFrameScaled. It is used to generate the final analysis, where a table of the percentage of observations for each individual and each cluster is created.}

\item{withOrWithoutZeroClust}{This parameter controls if the generated result should contain a cluster in origo or not. This information is given by dOptPenalty, again.}
}
\value{
A list with two components:
\describe{
    \item{realloClusterVector}{A vector with the same length as number of rows in the inDataFrameScaled, where the cluster identity of each observation is noted.}
    \item{realloClusterPercentagesForAllIds}{A matrix showing the percentage of observations for each id in each cluster.}
}
}
\description{
Here, observations of a dataset are allocated to a set of preestablished cluster centers. This is intended to be used for the test set in train-test dataset situations. It is called "predict" as most similar functions of other clustering algorithms have this term.
}
\examples{
#Generate a default size dataframe with bimodally distributed data
x <- generateBimodalData()

#Scale this datamframe
x_scaled <- dScale(x[,2:ncol(x)])

#Divide this scaled dataframe in two parts
x_scaled_train <- x_scaled[1:5000,]
x_scaled_test <- x_scaled[5001:10000,]

#Create two completely meaningless ids vectors
id_vector_train <- c(rep("Train 1", 2500), rep("Train 2", 2500))
id_vector_test <- c(rep("Test 3", 2500), rep("Test 4", 2500))

#Set a reasonable working directory, e.g.
setwd("~/Desktop")

#Run the dOptAndClust function for the train set
x_dOptAndClust_train <- dOptAndClust(x_scaled_train, ids=id_vector_train)

#Separate the info from the dOpt and dClust functions
x_optim <- x_dOptAndClust_train[[1]]
x_dClust_train <- x_dOptAndClust_train[[2]]

#This is followed by running the actual function in question
x_dClust_test <- dAllocate(x_scaled_test, 
clusterCenters=x_dClust_train$clusterCentersWZeroVariables, 
withOrigoClust=x_optim[[4]][1,2], ids=id_vector_test)

#And finally plot this to see how great the overlap was:
xmatrix <- as.matrix(rbind(x_dClust_train$clusterPercentagesForAllIds, 
x_dClust_test$realloClusterPercentagesForAllIds))
library(gplots)
barplot2(xmatrix, beside = TRUE, legend = rownames(xmatrix))
title(main = "Difference between train and test set")
title(xlab = "Clusters")
title(ylab = "Percentage")
}
\seealso{
\code{\link{dOptPenalty}}, \code{\link{dClust}}
}
