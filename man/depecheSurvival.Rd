% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/depecheSurvival.R
\name{depecheSurvival}
\alias{depecheSurvival}
\title{Wilcoxon rank-sum or signed rank test comparison of subject groups in pKMRun result}
\usage{
depecheSurvival(idClusterData, survival, xYData, densContour,
  name = depecheSurvival, title = FALSE, dotsize = 400/sqrt(length(data)),
  highestAbsValues = max(abs(data)), bandColor = "black",
  createDirectory = TRUE, directoryName = "depeche Survival")
}
\arguments{
\item{xYData}{A dataframe with two columns. Each row contains information about the x and y positition in the field for that observation. It needs to have the same number of rows as idGroupClusterData.}

\item{densContour}{An object to create the density contours for the plot. If not present, it will be generated with the xYData. Useful when only a subfraction of a dataset is plotted, and a superimposition of the distribution of the whole dataset is of interest.}

\item{name}{The main name for the graph and the analysis.}

\item{title}{If there should be a title displayed on the plotting field. As the plotting field is saved as a png, this title cannot be removed as an object afterwards, as it is saved as coloured pixels. To simplify usage for publication, the default is FALSE, as the files are still named, eventhough no title appears on the plot.}

\item{bandColor}{The color of the contour bands. Defaults to black.}

\item{createDirectory}{If a directory (i.e. folder) should be created. Defaults to TRUE.}

\item{directoryName}{The name of the created directory, if it should be created.}

\item{idGroupClusterData}{This dataframe should contain three columns with information about the cluster identity (named "cluster"), the id (named "ids")and the group (named "group")identity for each observation.}

\item{maxAbsPlottingValues}{If multiple plots should be compared, it might be useful to define a similar color scale for all plots, so that the same color always means the same statistical value. Such a value can be added here. It defaults to the maximum Wilcoxon statistic that is generated in the analysis.}

\item{dotSize}{Simply the size of the dots. The default makes the dots smaller the more observations that are included.}
}
\value{
This function always returns a dataframe showing the Wilcoxon statistic and the p-value for each cluster, with an included adjustment for multiple comparisons (see above). It also returns a sne based plot showing which events that belong to a cluster dominated by the first or the second group.
}
\description{
This function is used to compare groups of individuals from whom comparable cytometry or other complex data has been generated.
}
\examples{
#Generate a dataframe with bimodally distributed data and 20 subsamplings.
x <- generateFlowCytometryData(samplings=100, ncols=7, observations=200)

#Split it into the samplings and order these according to the value in one of the columns
xSplitted <- split(x, x[,1])

names(xSplitted) <- seq(1:length(xSplitted))

orderingList <- list()
for(i in 2:4){
  y <- sapply(xSplitted, `[[`, i)
  yMean <- apply(y, 2, mean)
  yMeanRound <- sapply(yMean, round)
  orderingList[[i]] <- yMeanRound
}
orderingDf <- as.data.frame(t(do.call(rbind, orderingList)))
orderingDf$splitNumber <- seq(1:nrow(orderingDf))
orderingDfOrdered <- orderingDf[order(orderingDf[,1]),]

#Simulate some survival data
library(survsim)
surv.data <- simple.surv.sim(n=100, foltime=3600, dist.ev=c('llogistic'), anc.ev=c(0.69978200185280),beta0.ev=c(5.84298525742252),,anc.cens=1.17783687569519, beta0.cens=7.39773677281100,z=list(c("unif", 0.8, 1.2)))

#Combine the relevant parts from these survival objects
survival <- data.frame(surv.data$stop, surv.data$status)
colnames(survival) <- c("survivalTime", "status")

#Now sort the survival data in the same order as the means of the first column in the synthetic flow data.
survivalOrdered <- survival[order(survival$survivalTime),]
survivalOrdered$Identity <- orderingDfOrdered$splitNumber
survivalMatched <- survivalOrdered[order(survivalOrdered$Identity),]

#Scale the flow data (not actually necessary in this artificial example due to the nature of the generated data)
x_scaled <- quantileScale(x[2:ncol(x)])

#Create the optimized number of clusters for this dataset
x_optim <- pKMOptim(x_scaled, iterations=50, bootstrapObservations=1000)
x_pKM <- pKMRun(x_scaled, regVec=x_optim[[1]][["optimalRegularizationValue"]], withOrWithoutZeroClust=x_optim[[1]][["withOrWithoutZeroClust"]], iterations=1, ids=x[,1])

#Run Barnes Hut tSNE on this dataset. XXX NB! This takes a long while (a few minutes) as the algorithm is slow.
library(Rtsne)
xSNE <- Rtsne(x_scaled, pca=FALSE)

#Create the idClusterData object
idClusterData <- data.frame(x[,1], x_pKM$clusterVector)
colnames(idClusterData) <- c("id", "cluster")


#Set a reasonable working directory, e.g.
setwd("~/Desktop")

#And finally run the function
depecheSurvival(idGroupClusterData=idGroupClusterData, survival=survival, xYData=as.data.frame(xSNE$Y))
}
