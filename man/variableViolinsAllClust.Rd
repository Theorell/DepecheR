% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/variableViolinsAllClust.R
\name{variableViolinsAllClust}
\alias{variableViolinsAllClust}
\title{Create violin plots for all non-penalized variable for all clusters}
\usage{
variableViolinsAllClust(clusterCenters, clusterVector, inDataFrame)
}
\arguments{
\item{clusterCenters}{A matrix containing information about where the centers are in all the variables that contributed to creating the cluster with the given penalty term.}

\item{clusterVector}{A vector with information about the cluster identity of all observations. Needs to have the same length as the number of rows in the inDataFrame.}

\item{inDataFrame}{A dataframe that has been used to generate the cluster vector and the clusterCenters. Note that the scaling does not matter in this case, as each variable wil be plotted separately.}
}
\value{
One graph is created for each non-penalized variable in each non-penalized cluster, which often means that the function creates a vast number of graphs. The graphs are sorted into subfolders for each cluster.
}
\description{
Here, violin plots of a specific cluster and the total population are created for each variable that has not been penalized away in the penalized K-means analysis. As al such plots are generated for each cluster, this function creates a great number of plots in most instances.
}
\examples{
#Generate a default size dataframe with bimodally distributed data
x <- generateFlowCytometryData(samplings=2, ncols=8)

#Scale this datamframe
x_scaled <- quantileScale(x[2:ncol(x)])

#Set a reasonable working directory, e.g.
setwd("~/Desktop")

#Run the Optim function to get good starting points
x_optim <- Optim(x_scaled, iterations=5, bootstrapObservations=1000)

#Then run the clustering function
x_ <- pKMRun(x_scaled, regVec=x_optim[[1]][["optimalRegularizationValue"]], 
withOrWithoutZeroClust=x_optim[[1]][["withOrWithoutZeroClust"]], iterations=2, ids=x[,1])

#And finally create all the clusters
variableViolinsAllClust(x_$penalizedClusterCenters, as.numeric(x_$clusterVector), x[,2:ncol(x)])
}
