% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dClust.R, R/dClust_2.R
\name{dClust}
\alias{dClust}
\alias{dClust}
\title{Function to run penalized K means}
\usage{
dClust(inDataFrameScaled, sampleSize, penaltyOffset, withOrigoClust,
  initCenters = 30, iterations = 10, ids)

dClust(inDataFrameScaled, sampleSize, penaltyOffset, withOrigoClust,
  initCenters = 30, iterations = 10, ids)
}
\arguments{
\item{inDataFrameScaled}{A dataframe with the data that will be used to create the clustering. The data in this dataframe should be scaled in a proper way. Empirically, many datasets seem to be clustered in a meaningful way if they are scaled with the quantileScale function.}

\item{sampleSize}{Number of observations that shoult be included in the initial clustering step. Defaults to all rows in inDataFrameScaled. If another number, a sample is created from inDataFrameScaled. This is extra useful when clustering very large datasets. Replacement is set to TRUE.}

\item{penaltyOffset}{The parameter that controls the level of penalization. Preferrably, it should be inherited from a dClustOpt run, as the algorithm will then generate the most stable result.}

\item{initCenters}{Number of starting points for clusters. This essentially means that it is the highest possible number of clusters that can be defined. The higher the number, the greater the precision, but the computing time is also increased with the number of starting points. Default is 30.}

\item{iterations}{As it sounds, this controls how many iterations that are performed, among which the most stable is chosen. If dClustOpt has been performed before, this number should not need to be extensive. Default is 10.}

\item{ids}{A vector of the same length as rows in the inDataFrameScaled. It is used to generate the final analysis, where a table of the percentage of observations for each individual and each cluster is created.}

\item{withOrWithoutZeroClust}{This parameter controls if the generated result should contain a cluster in origo or not. This information is given by dClustOpt, again.}

\item{inDataFrameScaled}{A dataframe with the data that will be used to create the clustering. The data in this dataframe should be scaled in a proper way. Empirically, many datasets seem to be clustered in a meaningful way if they are scaled with the quantileScale function.}

\item{sampleSize}{Number of observations that shoult be included in the initial clustering step. Defaults to all rows in inDataFrameScaled. If another number, a sample is created from inDataFrameScaled. This is extra useful when clustering very large datasets. Replacement is set to TRUE.}

\item{penaltyOffset}{The parameter that controls the level of penalization. Preferrably, it should be inherited from a dClustOpt run, as the algorithm will then generate the most stable result.}

\item{withOrWithoutZeroClust}{This parameter controls if the generated result should contain a cluster in origo or not. This information is given by dClustOpt, again.}

\item{initCenters}{Number of starting points for clusters. This essentially means that it is the highest possible number of clusters that can be defined. The higher the number, the greater the precision, but the computing time is also increased with the number of starting points. Default is 30.}

\item{iterations}{As it sounds, this controls how many iterations that are performed, among which the most stable is chosen. If dClustOpt has been performed before, this number should not need to be extensive. Default is 10.}

\item{ids}{A vector of the same length as rows in the inDataFrameScaled. It is used to generate the final analysis, where a table of the percentage of observations for each individual and each cluster is created.}
}
\value{
A list with three components:
\describe{
    \item{clusterVector}{A vector with the same length as number of rows in the inDataFrameScaled, where the cluster identity of each observation is noted.}
    \item{clusterCenters}{A matrix containing information about where the centers are in all the variables that contributed to creating the cluster with the given penalty term.}
    \item{clusterPercentagesForAllIds}{A matrix showing the percentage of observations for each id in each cluster.}
}

A list with three components:
\describe{
    \item{clusterVector}{A vector with the same length as number of rows in the inDataFrameScaled, where the cluster identity of each observation is noted.}
    \item{clusterCenters}{A matrix containing information about where the centers are in all the variables that contributed to creating the cluster with the given penalty term.}
    \item{clusterPercentagesForAllIds}{A matrix showing the percentage of observations for each id in each cluster.}
}
}
\description{
This function is the core user function of the Depeche package. It clusters the data with a penalized version of K-means.

This function is the core user function of the Depeche package. It clusters the data with a penalized version of K-means.
}
\examples{
#Generate a default size dataframe with bimodally distributed data
x <- generateFlowCytometryData(samplings=2)

#Scale this datamframe
x_scaled <- quantileScale(x[,2:ncol(x)])

#Set a reasonable working directory, e.g.
setwd("~/Desktop")

#Run the dClustOpt function to get good starting points
x_optim <- dClustOpt(x_scaled, iterations=10, bootstrapObservations=1000)

#Then run the actual function
x_dClust <- dClust(x_scaled, penaltyOffset=x_optim[[1]][["bestPenaltyOffset"]], 
withOrigoClust=x_optim[[1]][["withOrigoClust"]], iterations=1, ids=x[,1])

#And finally look at your great result
str(x_dClust)
#Generate a default size dataframe with bimodally distributed data
x <- generateFlowCytometryData(samplings=2)

#Scale this datamframe
x_scaled <- quantileScale(x[,2:ncol(x)])

#Set a reasonable working directory, e.g.
setwd("~/Desktop")

#Run the dClustOpt function to get good starting points
x_optim <- dClustOpt(x_scaled, iterations=10, bootstrapObservations=1000)

#Then run the actual function
x_dClust <- dClust(x_scaled, penaltyOffset=x_optim[[1]][["bestPenaltyOffset"]], 
withOrigoClust=x_optim[[1]][["withOrigoClust"]], iterations=1, ids=x[,1])

#And finally look at your great result
str(x_dClust)
}
\seealso{
\code{\link{dClustOpt}}, \code{\link{dClustPredict}}

\code{\link{dClustOpt}}, \code{\link{dClustPredict}}
}
