% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dColorVector.R
\name{dColorVector}
\alias{dColorVector}
\title{Create a vector of colors of the same length as the data}
\usage{
dColorVector(x, order = unique(x), colorScale = "viridis")
}
\arguments{
\item{x}{A vector, in most cases of identities of individuals or clusters ect.}

\item{order}{The order, folowing a rainbow distribution, that the colors should be in in the output vector. Defaults to the order that the unique values in x occurs.}

\item{colorScale}{The color scale. Inherited from the viridis, gplots and grDevices packages (and the package-specific "dark_rainbow"). Seven possible scales are pre-made: inferno, magma, plasma, viridis, rich_colors, rainbow and dark_rainbow. User specified vectors of colors (e.g. c("#FF0033", "#03AF49")) are also accepted.}
}
\value{
A vector, the same length as x with each unique value substitutet with a color.
}
\description{
This function takes a vector x and a shorter ordering vector with all the unique values of the x vector in the specific order that the colors should be in and returns a vector of RGB colors the same length as the initial x vector.
}
\examples{
#Generate a dataframe with bimodally distributed data and a few separate subsamplings
x <- generateBimodalData(samplings=5, observations=2000)

#Scale the data (not actually necessary in this artificial 
#example due to the nature of the generated data)
x_scaled <- dScale(x=x[2:ncol(x)])

#Run Barnes Hut tSNE on this. 
library(Rtsne.multicore)
xSNE <- Rtsne.multicore(as.matrix(dScale(x[2:ncol(x)])), pca=FALSE)

#Now use our function
xColors <- dColorVector(x[,1])

#Set a reasonable working directory, e.g.
setwd("~/Desktop")

#Plot all ids together and use rainbowColors
dDensityPlot(xYData=as.data.frame(xSNE$Y), idsVector=x[,1], commonName="All_samplings", 
color=xColors, createDirectory=FALSE)

}
\seealso{
\code{\link{dDensityPlot}}, \code{\link{dColorPlot}}, \code{\link{dViolins}}
}
